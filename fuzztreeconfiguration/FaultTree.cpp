// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <faultTree.h>

namespace ft
{
  // Annotation
  // 


  // Probability
  // 


  // AnnotatedElement
  // 

  const AnnotatedElement::AnnotationsSequence& AnnotatedElement::
  annotations () const
  {
    return this->annotations_;
  }

  AnnotatedElement::AnnotationsSequence& AnnotatedElement::
  annotations ()
  {
    return this->annotations_;
  }

  void AnnotatedElement::
  annotations (const AnnotationsSequence& s)
  {
    this->annotations_ = s;
  }

  const AnnotatedElement::IdType& AnnotatedElement::
  id () const
  {
    return this->id_.get ();
  }

  AnnotatedElement::IdType& AnnotatedElement::
  id ()
  {
    return this->id_.get ();
  }

  void AnnotatedElement::
  id (const IdType& x)
  {
    this->id_.set (x);
  }

  const AnnotatedElement::NameOptional& AnnotatedElement::
  name () const
  {
    return this->name_;
  }

  AnnotatedElement::NameOptional& AnnotatedElement::
  name ()
  {
    return this->name_;
  }

  void AnnotatedElement::
  name (const NameType& x)
  {
    this->name_.set (x);
  }

  void AnnotatedElement::
  name (const NameOptional& x)
  {
    this->name_ = x;
  }

  void AnnotatedElement::
  name (::std::auto_ptr< NameType > x)
  {
    this->name_.set (x);
  }


  // Model
  // 


  // Node
  // 

  const Node::ChildrenSequence& Node::
  children () const
  {
    return this->children_;
  }

  Node::ChildrenSequence& Node::
  children ()
  {
    return this->children_;
  }

  void Node::
  children (const ChildrenSequence& s)
  {
    this->children_ = s;
  }

  const Node::XOptional& Node::
  x () const
  {
    return this->x_;
  }

  Node::XOptional& Node::
  x ()
  {
    return this->x_;
  }

  void Node::
  x (const XType& x)
  {
    this->x_.set (x);
  }

  void Node::
  x (const XOptional& x)
  {
    this->x_ = x;
  }

  const Node::YOptional& Node::
  y () const
  {
    return this->y_;
  }

  Node::YOptional& Node::
  y ()
  {
    return this->y_;
  }

  void Node::
  y (const YType& x)
  {
    this->y_.set (x);
  }

  void Node::
  y (const YOptional& x)
  {
    this->y_ = x;
  }


  // ChildNode
  // 


  // FaultTree
  // 

  const FaultTree::TopEventType& FaultTree::
  topEvent () const
  {
    return this->topEvent_.get ();
  }

  FaultTree::TopEventType& FaultTree::
  topEvent ()
  {
    return this->topEvent_.get ();
  }

  void FaultTree::
  topEvent (const TopEventType& x)
  {
    this->topEvent_.set (x);
  }

  void FaultTree::
  topEvent (::std::auto_ptr< TopEventType > x)
  {
    this->topEvent_.set (x);
  }


  // TopEvent
  // 


  // CrispProbability
  // 

  const CrispProbability::ValueType& CrispProbability::
  value () const
  {
    return this->value_.get ();
  }

  CrispProbability::ValueType& CrispProbability::
  value ()
  {
    return this->value_.get ();
  }

  void CrispProbability::
  value (const ValueType& x)
  {
    this->value_.set (x);
  }


  // Gate
  // 


  // And
  // 


  // Or
  // 


  // Xor
  // 


  // VotingOr
  // 

  const VotingOr::KType& VotingOr::
  k () const
  {
    return this->k_.get ();
  }

  VotingOr::KType& VotingOr::
  k ()
  {
    return this->k_.get ();
  }

  void VotingOr::
  k (const KType& x)
  {
    this->k_.set (x);
  }


  // DynamicGate
  // 


  // Idlist
  //

  Idlist::
  Idlist ()
  : ::xsd::cxx::tree::list< ::xml_schema::Int, char > ( ::xml_schema::Flags (0), this)
  {
  }

  Idlist::
  Idlist (size_type n, const ::xml_schema::Int& x)
  : ::xsd::cxx::tree::list< ::xml_schema::Int, char > (n, x, this)
  {
  }

  Idlist::
  Idlist (const Idlist& o,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Int, char > (o, f, this)
  {
  }

  // ColdSpare
  // 

  const ColdSpare::SpareIdsType& ColdSpare::
  spareIds () const
  {
    return this->spareIds_.get ();
  }

  ColdSpare::SpareIdsType& ColdSpare::
  spareIds ()
  {
    return this->spareIds_.get ();
  }

  void ColdSpare::
  spareIds (const SpareIdsType& x)
  {
    this->spareIds_.set (x);
  }

  void ColdSpare::
  spareIds (::std::auto_ptr< SpareIdsType > x)
  {
    this->spareIds_.set (x);
  }


  // PriorityAnd
  // 

  const PriorityAnd::PriorityIdsType& PriorityAnd::
  priorityIds () const
  {
    return this->priorityIds_.get ();
  }

  PriorityAnd::PriorityIdsType& PriorityAnd::
  priorityIds ()
  {
    return this->priorityIds_.get ();
  }

  void PriorityAnd::
  priorityIds (const PriorityIdsType& x)
  {
    this->priorityIds_.set (x);
  }

  void PriorityAnd::
  priorityIds (::std::auto_ptr< PriorityIdsType > x)
  {
    this->priorityIds_.set (x);
  }


  // Sequence
  // 

  const Sequence::EventSequenceType& Sequence::
  eventSequence () const
  {
    return this->eventSequence_.get ();
  }

  Sequence::EventSequenceType& Sequence::
  eventSequence ()
  {
    return this->eventSequence_.get ();
  }

  void Sequence::
  eventSequence (const EventSequenceType& x)
  {
    this->eventSequence_.set (x);
  }

  void Sequence::
  eventSequence (::std::auto_ptr< EventSequenceType > x)
  {
    this->eventSequence_.set (x);
  }


  // FDEP
  // 

  const FDEP::TriggeredEventsType& FDEP::
  triggeredEvents () const
  {
    return this->triggeredEvents_.get ();
  }

  FDEP::TriggeredEventsType& FDEP::
  triggeredEvents ()
  {
    return this->triggeredEvents_.get ();
  }

  void FDEP::
  triggeredEvents (const TriggeredEventsType& x)
  {
    this->triggeredEvents_.set (x);
  }

  void FDEP::
  triggeredEvents (::std::auto_ptr< TriggeredEventsType > x)
  {
    this->triggeredEvents_.set (x);
  }


  // TransferIn
  // 

  const TransferIn::FromModelIdType& TransferIn::
  fromModelId () const
  {
    return this->fromModelId_.get ();
  }

  TransferIn::FromModelIdType& TransferIn::
  fromModelId ()
  {
    return this->fromModelId_.get ();
  }

  void TransferIn::
  fromModelId (const FromModelIdType& x)
  {
    this->fromModelId_.set (x);
  }

  const TransferIn::MaxCostsType& TransferIn::
  maxCosts () const
  {
    return this->maxCosts_.get ();
  }

  TransferIn::MaxCostsType& TransferIn::
  maxCosts ()
  {
    return this->maxCosts_.get ();
  }

  void TransferIn::
  maxCosts (const MaxCostsType& x)
  {
    this->maxCosts_.set (x);
  }

  TransferIn::MaxCostsType TransferIn::
  maxCostsDefaultValue ()
  {
    return MaxCostsType (0);
  }


  // UndevelopedEvent
  // 


  // BasicEvent
  // 

  const BasicEvent::ProbabilityType& BasicEvent::
  probability () const
  {
    return this->probability_.get ();
  }

  BasicEvent::ProbabilityType& BasicEvent::
  probability ()
  {
    return this->probability_.get ();
  }

  void BasicEvent::
  probability (const ProbabilityType& x)
  {
    this->probability_.set (x);
  }

  void BasicEvent::
  probability (::std::auto_ptr< ProbabilityType > x)
  {
    this->probability_.set (x);
  }


  // HouseEvent
  // 
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace ft
{
  // Annotation
  //

  Annotation::
  Annotation ()
  : ::xml_schema::Type ()
  {
  }

  Annotation::
  Annotation (const Annotation& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  Annotation::
  Annotation (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  Annotation::
  Annotation (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  Annotation::
  Annotation (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  Annotation* Annotation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Annotation (*this, f, c);
  }

  Annotation::
  ~Annotation ()
  {
  }

  // Probability
  //

  Probability::
  Probability ()
  : ::xml_schema::Type ()
  {
  }

  Probability::
  Probability (const Probability& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  Probability::
  Probability (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  Probability::
  Probability (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  Probability::
  Probability (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  Probability* Probability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Probability (*this, f, c);
  }

  Probability::
  ~Probability ()
  {
  }

  // AnnotatedElement
  //

  AnnotatedElement::
  AnnotatedElement (const IdType& id)
  : ::xml_schema::Type (),
    annotations_ (::xml_schema::Flags (), this),
    id_ (id, ::xml_schema::Flags (), this),
    name_ (::xml_schema::Flags (), this)
  {
  }

  AnnotatedElement::
  AnnotatedElement (const AnnotatedElement& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    annotations_ (x.annotations_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  AnnotatedElement::
  AnnotatedElement (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    annotations_ (f, this),
    id_ (f, this),
    name_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void AnnotatedElement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // annotations
      //
      if (n.name () == "annotations" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< AnnotationsType > r (
          AnnotationsTraits::create (i, f, this));

        this->annotations_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->name_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  AnnotatedElement* AnnotatedElement::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AnnotatedElement (*this, f, c);
  }

  AnnotatedElement::
  ~AnnotatedElement ()
  {
  }

  // Model
  //

  Model::
  Model (const IdType& id)
  : ::ft::AnnotatedElement (id)
  {
  }

  Model::
  Model (const Model& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::ft::AnnotatedElement (x, f, c)
  {
  }

  Model::
  Model (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::ft::AnnotatedElement (e, f, c)
  {
  }

  Model* Model::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Model (*this, f, c);
  }

  Model::
  ~Model ()
  {
  }

  // Node
  //

  Node::
  Node (const IdType& id)
  : ::ft::AnnotatedElement (id),
    children_ (::xml_schema::Flags (), this),
    x_ (::xml_schema::Flags (), this),
    y_ (::xml_schema::Flags (), this)
  {
  }

  Node::
  Node (const Node& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::ft::AnnotatedElement (x, f, c),
    children_ (x.children_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  Node::
  Node (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::ft::AnnotatedElement (e, f | ::xml_schema::Flags::base, c),
    children_ (f, this),
    x_ (f, this),
    y_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Node::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::AnnotatedElement::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // children
      //
      if (n.name () == "children" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ChildrenType > r (
          ChildrenTraits::create (i, f, this));

        this->children_.push_back (r);
        continue;
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (XTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (YTraits::create (i, f, this));
        continue;
      }
    }
  }

  Node* Node::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Node (*this, f, c);
  }

  Node::
  ~Node ()
  {
  }

  // ChildNode
  //

  ChildNode::
  ChildNode (const IdType& id)
  : ::ft::Node (id)
  {
  }

  ChildNode::
  ChildNode (const ChildNode& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::ft::Node (x, f, c)
  {
  }

  ChildNode::
  ChildNode (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::ft::Node (e, f, c)
  {
  }

  ChildNode* ChildNode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChildNode (*this, f, c);
  }

  ChildNode::
  ~ChildNode ()
  {
  }

  // FaultTree
  //

  FaultTree::
  FaultTree (const IdType& id,
             const TopEventType& topEvent)
  : ::ft::Model (id),
    topEvent_ (topEvent, ::xml_schema::Flags (), this)
  {
  }

  FaultTree::
  FaultTree (const IdType& id,
             ::std::auto_ptr< TopEventType >& topEvent)
  : ::ft::Model (id),
    topEvent_ (topEvent, ::xml_schema::Flags (), this)
  {
  }

  FaultTree::
  FaultTree (const FaultTree& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::ft::Model (x, f, c),
    topEvent_ (x.topEvent_, f, this)
  {
  }

  FaultTree::
  FaultTree (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::ft::Model (e, f | ::xml_schema::Flags::base, c),
    topEvent_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FaultTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::Model::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // topEvent
      //
      if (n.name () == "topEvent" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TopEventType > r (
          TopEventTraits::create (i, f, this));

        if (!topEvent_.present ())
        {
          this->topEvent_.set (r);
          continue;
        }
      }

      break;
    }

    if (!topEvent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "topEvent",
        "");
    }
  }

  FaultTree* FaultTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FaultTree (*this, f, c);
  }

  FaultTree::
  ~FaultTree ()
  {
  }

  // TopEvent
  //

  TopEvent::
  TopEvent (const IdType& id)
  : ::ft::Node (id)
  {
  }

  TopEvent::
  TopEvent (const TopEvent& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::ft::Node (x, f, c)
  {
  }

  TopEvent::
  TopEvent (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::ft::Node (e, f, c)
  {
  }

  TopEvent* TopEvent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TopEvent (*this, f, c);
  }

  TopEvent::
  ~TopEvent ()
  {
  }

  // CrispProbability
  //

  CrispProbability::
  CrispProbability (const ValueType& value)
  : ::ft::Probability (),
    value_ (value, ::xml_schema::Flags (), this)
  {
  }

  CrispProbability::
  CrispProbability (const CrispProbability& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::ft::Probability (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  CrispProbability::
  CrispProbability (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::ft::Probability (e, f | ::xml_schema::Flags::base, c),
    value_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void CrispProbability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  CrispProbability* CrispProbability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CrispProbability (*this, f, c);
  }

  CrispProbability::
  ~CrispProbability ()
  {
  }

  // Gate
  //

  Gate::
  Gate (const IdType& id)
  : ::ft::ChildNode (id)
  {
  }

  Gate::
  Gate (const Gate& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::ft::ChildNode (x, f, c)
  {
  }

  Gate::
  Gate (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::ft::ChildNode (e, f, c)
  {
  }

  Gate* Gate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Gate (*this, f, c);
  }

  Gate::
  ~Gate ()
  {
  }

  // And
  //

  And::
  And (const IdType& id)
  : ::ft::Gate (id)
  {
  }

  And::
  And (const And& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::ft::Gate (x, f, c)
  {
  }

  And::
  And (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::ft::Gate (e, f, c)
  {
  }

  And* And::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class And (*this, f, c);
  }

  And::
  ~And ()
  {
  }

  // Or
  //

  Or::
  Or (const IdType& id)
  : ::ft::Gate (id)
  {
  }

  Or::
  Or (const Or& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::ft::Gate (x, f, c)
  {
  }

  Or::
  Or (const ::xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::ft::Gate (e, f, c)
  {
  }

  Or* Or::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Or (*this, f, c);
  }

  Or::
  ~Or ()
  {
  }

  // Xor
  //

  Xor::
  Xor (const IdType& id)
  : ::ft::Gate (id)
  {
  }

  Xor::
  Xor (const Xor& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::ft::Gate (x, f, c)
  {
  }

  Xor::
  Xor (const ::xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::ft::Gate (e, f, c)
  {
  }

  Xor* Xor::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Xor (*this, f, c);
  }

  Xor::
  ~Xor ()
  {
  }

  // VotingOr
  //

  VotingOr::
  VotingOr (const IdType& id,
            const KType& k)
  : ::ft::Gate (id),
    k_ (k, ::xml_schema::Flags (), this)
  {
  }

  VotingOr::
  VotingOr (const VotingOr& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::ft::Gate (x, f, c),
    k_ (x.k_, f, this)
  {
  }

  VotingOr::
  VotingOr (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::ft::Gate (e, f | ::xml_schema::Flags::base, c),
    k_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void VotingOr::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::Gate::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "k" && n.namespace_ ().empty ())
      {
        this->k_.set (KTraits::create (i, f, this));
        continue;
      }
    }

    if (!k_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "k",
        "");
    }
  }

  VotingOr* VotingOr::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VotingOr (*this, f, c);
  }

  VotingOr::
  ~VotingOr ()
  {
  }

  // DynamicGate
  //

  DynamicGate::
  DynamicGate (const IdType& id)
  : ::ft::Gate (id)
  {
  }

  DynamicGate::
  DynamicGate (const DynamicGate& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::ft::Gate (x, f, c)
  {
  }

  DynamicGate::
  DynamicGate (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::ft::Gate (e, f, c)
  {
  }

  DynamicGate* DynamicGate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DynamicGate (*this, f, c);
  }

  DynamicGate::
  ~DynamicGate ()
  {
  }

  // Idlist
  //

  Idlist::
  Idlist (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Int, char > (e, f, this)
  {
  }

  Idlist::
  Idlist (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Int, char > (a, f, this)
  {
  }

  Idlist::
  Idlist (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Int, char > (s, e, f, this)
  {
  }

  Idlist* Idlist::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Idlist (*this, f, c);
  }

  Idlist::
  ~Idlist ()
  {
  }

  // ColdSpare
  //

  ColdSpare::
  ColdSpare (const IdType& id,
             const SpareIdsType& spareIds)
  : ::ft::DynamicGate (id),
    spareIds_ (spareIds, ::xml_schema::Flags (), this)
  {
  }

  ColdSpare::
  ColdSpare (const ColdSpare& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::ft::DynamicGate (x, f, c),
    spareIds_ (x.spareIds_, f, this)
  {
  }

  ColdSpare::
  ColdSpare (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::ft::DynamicGate (e, f | ::xml_schema::Flags::base, c),
    spareIds_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void ColdSpare::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::DynamicGate::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "spareIds" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< SpareIdsType > r (
          SpareIdsTraits::create (i, f, this));

        this->spareIds_.set (r);
        continue;
      }
    }

    if (!spareIds_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "spareIds",
        "");
    }
  }

  ColdSpare* ColdSpare::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ColdSpare (*this, f, c);
  }

  ColdSpare::
  ~ColdSpare ()
  {
  }

  // PriorityAnd
  //

  PriorityAnd::
  PriorityAnd (const IdType& id,
               const PriorityIdsType& priorityIds)
  : ::ft::DynamicGate (id),
    priorityIds_ (priorityIds, ::xml_schema::Flags (), this)
  {
  }

  PriorityAnd::
  PriorityAnd (const PriorityAnd& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::ft::DynamicGate (x, f, c),
    priorityIds_ (x.priorityIds_, f, this)
  {
  }

  PriorityAnd::
  PriorityAnd (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::ft::DynamicGate (e, f | ::xml_schema::Flags::base, c),
    priorityIds_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void PriorityAnd::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::DynamicGate::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "priorityIds" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< PriorityIdsType > r (
          PriorityIdsTraits::create (i, f, this));

        this->priorityIds_.set (r);
        continue;
      }
    }

    if (!priorityIds_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "priorityIds",
        "");
    }
  }

  PriorityAnd* PriorityAnd::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PriorityAnd (*this, f, c);
  }

  PriorityAnd::
  ~PriorityAnd ()
  {
  }

  // Sequence
  //

  Sequence::
  Sequence (const IdType& id,
            const EventSequenceType& eventSequence)
  : ::ft::DynamicGate (id),
    eventSequence_ (eventSequence, ::xml_schema::Flags (), this)
  {
  }

  Sequence::
  Sequence (const Sequence& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::ft::DynamicGate (x, f, c),
    eventSequence_ (x.eventSequence_, f, this)
  {
  }

  Sequence::
  Sequence (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::ft::DynamicGate (e, f | ::xml_schema::Flags::base, c),
    eventSequence_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void Sequence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::DynamicGate::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "eventSequence" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< EventSequenceType > r (
          EventSequenceTraits::create (i, f, this));

        this->eventSequence_.set (r);
        continue;
      }
    }

    if (!eventSequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eventSequence",
        "");
    }
  }

  Sequence* Sequence::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Sequence (*this, f, c);
  }

  Sequence::
  ~Sequence ()
  {
  }

  // FDEP
  //

  FDEP::
  FDEP (const IdType& id,
        const TriggeredEventsType& triggeredEvents)
  : ::ft::DynamicGate (id),
    triggeredEvents_ (triggeredEvents, ::xml_schema::Flags (), this)
  {
  }

  FDEP::
  FDEP (const FDEP& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::ft::DynamicGate (x, f, c),
    triggeredEvents_ (x.triggeredEvents_, f, this)
  {
  }

  FDEP::
  FDEP (const ::xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::ft::DynamicGate (e, f | ::xml_schema::Flags::base, c),
    triggeredEvents_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void FDEP::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::DynamicGate::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "triggeredEvents" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TriggeredEventsType > r (
          TriggeredEventsTraits::create (i, f, this));

        this->triggeredEvents_.set (r);
        continue;
      }
    }

    if (!triggeredEvents_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "triggeredEvents",
        "");
    }
  }

  FDEP* FDEP::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FDEP (*this, f, c);
  }

  FDEP::
  ~FDEP ()
  {
  }

  // TransferIn
  //

  TransferIn::
  TransferIn (const IdType& id,
              const FromModelIdType& fromModelId)
  : ::ft::ChildNode (id),
    fromModelId_ (fromModelId, ::xml_schema::Flags (), this),
    maxCosts_ (maxCostsDefaultValue (), ::xml_schema::Flags (), this)
  {
  }

  TransferIn::
  TransferIn (const TransferIn& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::ft::ChildNode (x, f, c),
    fromModelId_ (x.fromModelId_, f, this),
    maxCosts_ (x.maxCosts_, f, this)
  {
  }

  TransferIn::
  TransferIn (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::ft::ChildNode (e, f | ::xml_schema::Flags::base, c),
    fromModelId_ (f, this),
    maxCosts_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void TransferIn::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::ChildNode::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "fromModelId" && n.namespace_ ().empty ())
      {
        this->fromModelId_.set (FromModelIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxCosts" && n.namespace_ ().empty ())
      {
        this->maxCosts_.set (MaxCostsTraits::create (i, f, this));
        continue;
      }
    }

    if (!fromModelId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fromModelId",
        "");
    }

    if (!maxCosts_.present ())
    {
      this->maxCosts_.set (maxCostsDefaultValue ());
    }
  }

  TransferIn* TransferIn::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransferIn (*this, f, c);
  }

  TransferIn::
  ~TransferIn ()
  {
  }

  // UndevelopedEvent
  //

  UndevelopedEvent::
  UndevelopedEvent (const IdType& id)
  : ::ft::ChildNode (id)
  {
  }

  UndevelopedEvent::
  UndevelopedEvent (const UndevelopedEvent& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::ft::ChildNode (x, f, c)
  {
  }

  UndevelopedEvent::
  UndevelopedEvent (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::ft::ChildNode (e, f, c)
  {
  }

  UndevelopedEvent* UndevelopedEvent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UndevelopedEvent (*this, f, c);
  }

  UndevelopedEvent::
  ~UndevelopedEvent ()
  {
  }

  // BasicEvent
  //

  BasicEvent::
  BasicEvent (const IdType& id,
              const ProbabilityType& probability)
  : ::ft::ChildNode (id),
    probability_ (probability, ::xml_schema::Flags (), this)
  {
  }

  BasicEvent::
  BasicEvent (const BasicEvent& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::ft::ChildNode (x, f, c),
    probability_ (x.probability_, f, this)
  {
  }

  BasicEvent::
  BasicEvent (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::ft::ChildNode (e, f | ::xml_schema::Flags::base, c),
    probability_ (f, this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void BasicEvent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::ft::ChildNode::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // probability
      //
      if (n.name () == "probability" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< ProbabilityType > r (
          ProbabilityTraits::create (i, f, this));

        if (!probability_.present ())
        {
          this->probability_.set (r);
          continue;
        }
      }

      break;
    }

    if (!probability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "probability",
        "");
    }
  }

  BasicEvent* BasicEvent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BasicEvent (*this, f, c);
  }

  BasicEvent::
  ~BasicEvent ()
  {
  }

  // HouseEvent
  //

  HouseEvent::
  HouseEvent (const IdType& id,
              const ProbabilityType& probability)
  : ::ft::BasicEvent (id,
                      probability)
  {
  }

  HouseEvent::
  HouseEvent (const HouseEvent& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::ft::BasicEvent (x, f, c)
  {
  }

  HouseEvent::
  HouseEvent (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::ft::BasicEvent (e, f, c)
  {
  }

  HouseEvent* HouseEvent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HouseEvent (*this, f, c);
  }

  HouseEvent::
  ~HouseEvent ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ft
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace ft
{
  void
  operator<< (::xercesc::DOMElement& e, const Annotation& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Annotation&)
  {
  }

  void
  operator<< (::xml_schema::ListStream&,
              const Annotation&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const Probability& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Probability&)
  {
  }

  void
  operator<< (::xml_schema::ListStream&,
              const Probability&)
  {
  }

  void
  operator<< (::xercesc::DOMElement& e, const AnnotatedElement& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // annotations
    //
    for (AnnotatedElement::AnnotationsConstIterator
         b (i.annotations ().begin ()), n (i.annotations ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "annotations",
          e));

      s << *b;
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // name
    //
    if (i.name ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "name",
          e));

      a << *i.name ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Model& i)
  {
    e << static_cast< const ::ft::AnnotatedElement& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Node& i)
  {
    e << static_cast< const ::ft::AnnotatedElement& > (i);

    // children
    //
    for (Node::ChildrenConstIterator
         b (i.children ().begin ()), n (i.children ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "children",
          e));

      s << *b;
    }

    // x
    //
    if (i.x ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << *i.x ();
    }

    // y
    //
    if (i.y ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << *i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ChildNode& i)
  {
    e << static_cast< const ::ft::Node& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const FaultTree& i)
  {
    e << static_cast< const ::ft::Model& > (i);

    // topEvent
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "topEvent",
          e));

      s << i.topEvent ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TopEvent& i)
  {
    e << static_cast< const ::ft::Node& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CrispProbability& i)
  {
    e << static_cast< const ::ft::Probability& > (i);

    // value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "value",
          e));

      a << ::xml_schema::AsDouble(i.value ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Gate& i)
  {
    e << static_cast< const ::ft::ChildNode& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const And& i)
  {
    e << static_cast< const ::ft::Gate& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Or& i)
  {
    e << static_cast< const ::ft::Gate& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Xor& i)
  {
    e << static_cast< const ::ft::Gate& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VotingOr& i)
  {
    e << static_cast< const ::ft::Gate& > (i);

    // k
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "k",
          e));

      a << i.k ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DynamicGate& i)
  {
    e << static_cast< const ::ft::Gate& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Idlist& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Int, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Idlist& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Int, char >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const Idlist& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Int, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ColdSpare& i)
  {
    e << static_cast< const ::ft::DynamicGate& > (i);

    // spareIds
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "spareIds",
          e));

      a << i.spareIds ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PriorityAnd& i)
  {
    e << static_cast< const ::ft::DynamicGate& > (i);

    // priorityIds
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "priorityIds",
          e));

      a << i.priorityIds ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Sequence& i)
  {
    e << static_cast< const ::ft::DynamicGate& > (i);

    // eventSequence
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eventSequence",
          e));

      a << i.eventSequence ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const FDEP& i)
  {
    e << static_cast< const ::ft::DynamicGate& > (i);

    // triggeredEvents
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "triggeredEvents",
          e));

      a << i.triggeredEvents ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TransferIn& i)
  {
    e << static_cast< const ::ft::ChildNode& > (i);

    // fromModelId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "fromModelId",
          e));

      a << i.fromModelId ();
    }

    // maxCosts
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "maxCosts",
          e));

      a << i.maxCosts ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const UndevelopedEvent& i)
  {
    e << static_cast< const ::ft::ChildNode& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const BasicEvent& i)
  {
    e << static_cast< const ::ft::ChildNode& > (i);

    // probability
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "probability",
          e));

      s << i.probability ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HouseEvent& i)
  {
    e << static_cast< const ::ft::BasicEvent& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

