#!/usr/bin/env python

import os, pprint, sys, shutil
try:
    import json
except ImportError:
    import simplejson as json

from setuptools import setup
from distutils.command.build import build as _build
from distutils.command.clean import clean as _clean

# check FuzzEd/__init__.py for the project version number
from FuzzEd import __version__, util

def check_pythonversion():
    if sys.version_info.major != 2:
        print('You must use Python 2, since django demands this')
        exit(-1)
    if sys.version_info.major == 2 and sys.version_info.minor < 7:
        print('You must use Python 2.7+, since django-require demands this')
        exit(-1)
check_pythonversion()

def build_xmlschema_wrapper():
    # Copy most recent schema files from calc server
    shutil.copyfile('analysis/code/net.fuzztree.model.analysis/model/AnalysisXML.xsd', 'FuzzEd/static/xsd/analysis.xsd')
    shutil.copyfile('analysis/code/net.fuzztree.model.fuzztree/model/FuzzTreeXML.xsd', 'FuzzEd/static/xsd/fuzztree.xsd')

    # Remove old binding files and generate new ones
    for file_name in ['xml_fuzztree.py', 'xml_analysis.py']:
        path_name = 'FuzzEd/models/%s' % file_name

        if os.path.exists(path_name):
            os.remove(path_name)
    os.system('pyxbgen --binding-root=FuzzEd/models/ -u FuzzEd/static/xsd/analysis.xsd \
              -m xml_analysis -u FuzzEd/static/xsd/fuzztree.xsd -m xml_fuzztree')

def build_naturaldocs():
    # Build natural docs in 'docs' subdirectory
    if not os.path.exists('docs'):
        os.mkdir('docs')
    os.system('tools/NaturalDocs/NaturalDocs -i FuzzEd -o HTML docs -p docs')

def build_django_require():
    # Use Django collectstatic, which triggers django-require optimization
    os.system('./manage.py collectstatic -v3 --noinput')

def build_notations():
    notations_dir = 'FuzzEd/static/notations/'
    file_list = os.listdir(notations_dir)
    notations = []

    for file_path in [os.path.join(notations_dir, file_name) for file_name in file_list]:
        if os.path.isfile(file_path) and file_path.endswith('.json'):

            with open(file_path) as handle:
                notations.append(json.loads(handle.read()))
    resolve_inheritance(notations)

    with open('FuzzEd/models/notations.py', 'w') as out:
        old_stdout, sys.stdout = sys.stdout, out

        print '# DO NOT EDIT! This file is auto-generated by "setup.py build"\n'
        print 'notations = ',
        pprint.pprint(notations)
        print '\nby_kind = {notation[\'kind\']: notation for notation in notations}\n'
        print 'choices = ',
        pprint.pprint(generate_choices(notations))
        print '\nnode_choices = ',
        pprint.pprint(generate_node_choices(notations))
        print '\n# END OF GENERATED CONTENT'

        sys.stdout = old_stdout

def generate_choices(notations):
    return [(notation['kind'], notation['name']) for notation in notations]

def generate_node_choices(notations):
    node_choices = []

    for notation in notations:
        nodes = notation['nodes']
        node_category = (notation['name'],)
        node_category_choices = ()

        for node_kind, node in nodes.items():
            if not 'name' in node: continue
            node_category_choices += ((node_kind, node['name']),)

        node_category += (node_category_choices,)
        node_choices.append(node_category)

    return node_choices

def resolve_inheritance(notations):
    for notation in notations:
        nodes = notation['nodes']
        node_cache = {}

        for node_name, node in nodes.items():
            nodes[node_name] = inherit(node_name, node, nodes, node_cache)

def inherit(node_name, node, nodes, node_cache):
    inherits_from = node.get('inherits')

    if not inherits_from:
        node_cache[node_name] = node
        return node

    elif inherits_from not in node_cache:
        inherit(inherits_from, nodes[inherits_from], nodes, node_cache)

    resolved = util.extend({}, node_cache[inherits_from], node, deep=True)
    node_cache[node_name] = resolved

    return resolved

# Our overloaded 'setup.py build' command
class build(_build):
    def run(self):
        _build.run(self)
        build_xmlschema_wrapper()
        build_notations()
        build_naturaldocs()
        build_django_require()

def clean_docs():
    os.system('rm -rf docs')

def clean_pycs():
    # Clean all pyc files recursively
    for root, dirs, files in os.walk('FuzzEd'):
        for name in files:
            if name.endswith('.pyc'):
                fullname = os.path.join(root, name)
                print 'Removing %s' % fullname
                os.remove(fullname)

# Our overloaded 'setup.py clean' command
class clean(_clean):
    def run(self):
        _clean.run(self)
        clean_docs()
        clean_pycs()

setup(
    name = 'FuzzEd',
    version = __version__,
    install_requires=[
        'django',
        'south',
        'openid2rp',
        'django-require',
        'minbool',
        'pyxb'
    ],
    packages = ['FuzzEd'],
    include_package_data = True,
    cmdclass={
        'build': build,
        'clean': clean
    },
    maintainer = 'Peter Troeger',
    maintainer_email = 'peter.troeger@hpi.uni-potsdam.de',
	url = 'https://bitbucket.org/troeger/fuzztrees'
)
