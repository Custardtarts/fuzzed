// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <configurations.h>

namespace configurations
{
  // Choice
  // 


  // IntegerToChoiceMap
  // 

  const IntegerToChoiceMap::ValueType& IntegerToChoiceMap::
  value () const
  {
    return this->value_.get ();
  }

  IntegerToChoiceMap::ValueType& IntegerToChoiceMap::
  value ()
  {
    return this->value_.get ();
  }

  void IntegerToChoiceMap::
  value (const ValueType& x)
  {
    this->value_.set (x);
  }

  void IntegerToChoiceMap::
  value (::std::auto_ptr< ValueType > x)
  {
    this->value_.set (x);
  }

  const IntegerToChoiceMap::KeyType& IntegerToChoiceMap::
  key () const
  {
    return this->key_.get ();
  }

  IntegerToChoiceMap::KeyType& IntegerToChoiceMap::
  key ()
  {
    return this->key_.get ();
  }

  void IntegerToChoiceMap::
  key (const KeyType& x)
  {
    this->key_.set (x);
  }

  void IntegerToChoiceMap::
  key (::std::auto_ptr< KeyType > x)
  {
    this->key_.set (x);
  }


  // Configuration
  // 

  const Configuration::ChoiceSequence& Configuration::
  choice () const
  {
    return this->choice_;
  }

  Configuration::ChoiceSequence& Configuration::
  choice ()
  {
    return this->choice_;
  }

  void Configuration::
  choice (const ChoiceSequence& s)
  {
    this->choice_ = s;
  }

  const Configuration::IdType& Configuration::
  id () const
  {
    return this->id_.get ();
  }

  Configuration::IdType& Configuration::
  id ()
  {
    return this->id_.get ();
  }

  void Configuration::
  id (const IdType& x)
  {
    this->id_.set (x);
  }

  void Configuration::
  id (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const Configuration::CostsType& Configuration::
  costs () const
  {
    return this->costs_.get ();
  }

  Configuration::CostsType& Configuration::
  costs ()
  {
    return this->costs_.get ();
  }

  void Configuration::
  costs (const CostsType& x)
  {
    this->costs_.set (x);
  }


  // InclusionChoice
  // 

  const InclusionChoice::IncludedType& InclusionChoice::
  included () const
  {
    return this->included_.get ();
  }

  InclusionChoice::IncludedType& InclusionChoice::
  included ()
  {
    return this->included_.get ();
  }

  void InclusionChoice::
  included (const IncludedType& x)
  {
    this->included_.set (x);
  }


  // RedundancyChoice
  // 

  const RedundancyChoice::NType& RedundancyChoice::
  n () const
  {
    return this->n_.get ();
  }

  RedundancyChoice::NType& RedundancyChoice::
  n ()
  {
    return this->n_.get ();
  }

  void RedundancyChoice::
  n (const NType& x)
  {
    this->n_.set (x);
  }


  // FeatureChoice
  // 

  const FeatureChoice::FeatureIdType& FeatureChoice::
  featureId () const
  {
    return this->featureId_.get ();
  }

  FeatureChoice::FeatureIdType& FeatureChoice::
  featureId ()
  {
    return this->featureId_.get ();
  }

  void FeatureChoice::
  featureId (const FeatureIdType& x)
  {
    this->featureId_.set (x);
  }

  void FeatureChoice::
  featureId (::std::auto_ptr< FeatureIdType > x)
  {
    this->featureId_.set (x);
  }


  // TransferInChoice
  // 

  const TransferInChoice::ChosenConfigurationType& TransferInChoice::
  chosenConfiguration () const
  {
    return this->chosenConfiguration_.get ();
  }

  TransferInChoice::ChosenConfigurationType& TransferInChoice::
  chosenConfiguration ()
  {
    return this->chosenConfiguration_.get ();
  }

  void TransferInChoice::
  chosenConfiguration (const ChosenConfigurationType& x)
  {
    this->chosenConfiguration_.set (x);
  }

  void TransferInChoice::
  chosenConfiguration (::std::auto_ptr< ChosenConfigurationType > x)
  {
    this->chosenConfiguration_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace configurations
{
  // Choice
  //

  Choice::
  Choice ()
  : ::xml_schema::Type ()
  {
  }

  Choice::
  Choice (const Choice& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  Choice::
  Choice (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  Choice::
  Choice (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  Choice::
  Choice (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  Choice* Choice::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Choice (*this, f, c);
  }

  Choice::
  ~Choice ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Choice >
  _xsd_Choice_type_factory_init (
    "Choice",
    "http://www.fuzzed.org/configurations");

  // IntegerToChoiceMap
  //

  IntegerToChoiceMap::
  IntegerToChoiceMap (const ValueType& value,
                      const KeyType& key)
  : ::xml_schema::Type (),
    value_ (value, this),
    key_ (key, this)
  {
  }

  IntegerToChoiceMap::
  IntegerToChoiceMap (::std::auto_ptr< ValueType > value,
                      const KeyType& key)
  : ::xml_schema::Type (),
    value_ (value, this),
    key_ (key, this)
  {
  }

  IntegerToChoiceMap::
  IntegerToChoiceMap (const IntegerToChoiceMap& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this),
    key_ (x.key_, f, this)
  {
  }

  IntegerToChoiceMap::
  IntegerToChoiceMap (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this),
    key_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void IntegerToChoiceMap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "value",
            "",
            &::xsd::cxx::tree::factory_impl< ValueType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!value_.present ())
          {
            ::std::auto_ptr< ValueType > r (
              dynamic_cast< ValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->value_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        this->key_.set (KeyTraits::create (i, f, this));
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }
  }

  IntegerToChoiceMap* IntegerToChoiceMap::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntegerToChoiceMap (*this, f, c);
  }

  IntegerToChoiceMap& IntegerToChoiceMap::
  operator= (const IntegerToChoiceMap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
      this->key_ = x.key_;
    }

    return *this;
  }

  IntegerToChoiceMap::
  ~IntegerToChoiceMap ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, IntegerToChoiceMap >
  _xsd_IntegerToChoiceMap_type_factory_init (
    "IntegerToChoiceMap",
    "http://www.fuzzed.org/configurations");

  // Configuration
  //

  Configuration::
  Configuration (const IdType& id,
                 const CostsType& costs)
  : ::xml_schema::Type (),
    choice_ (this),
    id_ (id, this),
    costs_ (costs, this)
  {
  }

  Configuration::
  Configuration (const Configuration& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    choice_ (x.choice_, f, this),
    id_ (x.id_, f, this),
    costs_ (x.costs_, f, this)
  {
  }

  Configuration::
  Configuration (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    choice_ (this),
    id_ (this),
    costs_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Configuration::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // choice
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "choice",
            "",
            &::xsd::cxx::tree::factory_impl< ChoiceType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< ChoiceType > r (
            dynamic_cast< ChoiceType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->choice_.push_back (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "costs" && n.namespace_ ().empty ())
      {
        this->costs_.set (CostsTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!costs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "costs",
        "");
    }
  }

  Configuration* Configuration::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Configuration (*this, f, c);
  }

  Configuration& Configuration::
  operator= (const Configuration& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->choice_ = x.choice_;
      this->id_ = x.id_;
      this->costs_ = x.costs_;
    }

    return *this;
  }

  Configuration::
  ~Configuration ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Configuration >
  _xsd_Configuration_type_factory_init (
    "Configuration",
    "http://www.fuzzed.org/configurations");

  // InclusionChoice
  //

  InclusionChoice::
  InclusionChoice (const IncludedType& included)
  : ::configurations::Choice (),
    included_ (included, this)
  {
  }

  InclusionChoice::
  InclusionChoice (const InclusionChoice& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::configurations::Choice (x, f, c),
    included_ (x.included_, f, this)
  {
  }

  InclusionChoice::
  InclusionChoice (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::configurations::Choice (e, f | ::xml_schema::Flags::base, c),
    included_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void InclusionChoice::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "included" && n.namespace_ ().empty ())
      {
        this->included_.set (IncludedTraits::create (i, f, this));
        continue;
      }
    }

    if (!included_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "included",
        "");
    }
  }

  InclusionChoice* InclusionChoice::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InclusionChoice (*this, f, c);
  }

  InclusionChoice& InclusionChoice::
  operator= (const InclusionChoice& x)
  {
    if (this != &x)
    {
      static_cast< ::configurations::Choice& > (*this) = x;
      this->included_ = x.included_;
    }

    return *this;
  }

  InclusionChoice::
  ~InclusionChoice ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, InclusionChoice >
  _xsd_InclusionChoice_type_factory_init (
    "InclusionChoice",
    "http://www.fuzzed.org/configurations");

  // RedundancyChoice
  //

  RedundancyChoice::
  RedundancyChoice (const NType& n)
  : ::configurations::Choice (),
    n_ (n, this)
  {
  }

  RedundancyChoice::
  RedundancyChoice (const RedundancyChoice& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::configurations::Choice (x, f, c),
    n_ (x.n_, f, this)
  {
  }

  RedundancyChoice::
  RedundancyChoice (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::configurations::Choice (e, f | ::xml_schema::Flags::base, c),
    n_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RedundancyChoice::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "n" && n.namespace_ ().empty ())
      {
        this->n_.set (NTraits::create (i, f, this));
        continue;
      }
    }

    if (!n_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "n",
        "");
    }
  }

  RedundancyChoice* RedundancyChoice::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RedundancyChoice (*this, f, c);
  }

  RedundancyChoice& RedundancyChoice::
  operator= (const RedundancyChoice& x)
  {
    if (this != &x)
    {
      static_cast< ::configurations::Choice& > (*this) = x;
      this->n_ = x.n_;
    }

    return *this;
  }

  RedundancyChoice::
  ~RedundancyChoice ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, RedundancyChoice >
  _xsd_RedundancyChoice_type_factory_init (
    "RedundancyChoice",
    "http://www.fuzzed.org/configurations");

  // FeatureChoice
  //

  FeatureChoice::
  FeatureChoice (const FeatureIdType& featureId)
  : ::configurations::Choice (),
    featureId_ (featureId, this)
  {
  }

  FeatureChoice::
  FeatureChoice (const FeatureChoice& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::configurations::Choice (x, f, c),
    featureId_ (x.featureId_, f, this)
  {
  }

  FeatureChoice::
  FeatureChoice (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::configurations::Choice (e, f | ::xml_schema::Flags::base, c),
    featureId_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FeatureChoice::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "featureId" && n.namespace_ ().empty ())
      {
        this->featureId_.set (FeatureIdTraits::create (i, f, this));
        continue;
      }
    }

    if (!featureId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "featureId",
        "");
    }
  }

  FeatureChoice* FeatureChoice::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FeatureChoice (*this, f, c);
  }

  FeatureChoice& FeatureChoice::
  operator= (const FeatureChoice& x)
  {
    if (this != &x)
    {
      static_cast< ::configurations::Choice& > (*this) = x;
      this->featureId_ = x.featureId_;
    }

    return *this;
  }

  FeatureChoice::
  ~FeatureChoice ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, FeatureChoice >
  _xsd_FeatureChoice_type_factory_init (
    "FeatureChoice",
    "http://www.fuzzed.org/configurations");

  // TransferInChoice
  //

  TransferInChoice::
  TransferInChoice (const ChosenConfigurationType& chosenConfiguration)
  : ::configurations::Choice (),
    chosenConfiguration_ (chosenConfiguration, this)
  {
  }

  TransferInChoice::
  TransferInChoice (::std::auto_ptr< ChosenConfigurationType > chosenConfiguration)
  : ::configurations::Choice (),
    chosenConfiguration_ (chosenConfiguration, this)
  {
  }

  TransferInChoice::
  TransferInChoice (const TransferInChoice& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::configurations::Choice (x, f, c),
    chosenConfiguration_ (x.chosenConfiguration_, f, this)
  {
  }

  TransferInChoice::
  TransferInChoice (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::configurations::Choice (e, f | ::xml_schema::Flags::base, c),
    chosenConfiguration_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TransferInChoice::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // chosenConfiguration
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "chosenConfiguration",
            "",
            &::xsd::cxx::tree::factory_impl< ChosenConfigurationType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!chosenConfiguration_.present ())
          {
            ::std::auto_ptr< ChosenConfigurationType > r (
              dynamic_cast< ChosenConfigurationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->chosenConfiguration_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!chosenConfiguration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "chosenConfiguration",
        "");
    }
  }

  TransferInChoice* TransferInChoice::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransferInChoice (*this, f, c);
  }

  TransferInChoice& TransferInChoice::
  operator= (const TransferInChoice& x)
  {
    if (this != &x)
    {
      static_cast< ::configurations::Choice& > (*this) = x;
      this->chosenConfiguration_ = x.chosenConfiguration_;
    }

    return *this;
  }

  TransferInChoice::
  ~TransferInChoice ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransferInChoice >
  _xsd_TransferInChoice_type_factory_init (
    "TransferInChoice",
    "http://www.fuzzed.org/configurations");
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace configurations
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace configurations
{
  void
  operator<< (::xercesc::DOMElement& e, const Choice& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Choice&)
  {
  }

  void
  operator<< (::xml_schema::ListStream&,
              const Choice&)
  {
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Choice >
  _xsd_Choice_type_serializer_init (
    "Choice",
    "http://www.fuzzed.org/configurations");


  void
  operator<< (::xercesc::DOMElement& e, const IntegerToChoiceMap& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const IntegerToChoiceMap::ValueType& x (i.value ());
      if (typeid (IntegerToChoiceMap::ValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "value",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "value",
          "",
          false, false, e, x);
    }

    // key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "key",
          e));

      a << i.key ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IntegerToChoiceMap >
  _xsd_IntegerToChoiceMap_type_serializer_init (
    "IntegerToChoiceMap",
    "http://www.fuzzed.org/configurations");


  void
  operator<< (::xercesc::DOMElement& e, const Configuration& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // choice
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Configuration::ChoiceConstIterator
           b (i.choice ().begin ()), n (i.choice ().end ());
           b != n; ++b)
      {
        if (typeid (Configuration::ChoiceType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "choice",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "choice",
            "",
            false, false, e, *b);
      }
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // costs
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "costs",
          e));

      a << i.costs ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Configuration >
  _xsd_Configuration_type_serializer_init (
    "Configuration",
    "http://www.fuzzed.org/configurations");


  void
  operator<< (::xercesc::DOMElement& e, const InclusionChoice& i)
  {
    e << static_cast< const ::configurations::Choice& > (i);

    // included
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "included",
          e));

      a << i.included ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, InclusionChoice >
  _xsd_InclusionChoice_type_serializer_init (
    "InclusionChoice",
    "http://www.fuzzed.org/configurations");


  void
  operator<< (::xercesc::DOMElement& e, const RedundancyChoice& i)
  {
    e << static_cast< const ::configurations::Choice& > (i);

    // n
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "n",
          e));

      a << i.n ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RedundancyChoice >
  _xsd_RedundancyChoice_type_serializer_init (
    "RedundancyChoice",
    "http://www.fuzzed.org/configurations");


  void
  operator<< (::xercesc::DOMElement& e, const FeatureChoice& i)
  {
    e << static_cast< const ::configurations::Choice& > (i);

    // featureId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "featureId",
          e));

      a << i.featureId ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FeatureChoice >
  _xsd_FeatureChoice_type_serializer_init (
    "FeatureChoice",
    "http://www.fuzzed.org/configurations");


  void
  operator<< (::xercesc::DOMElement& e, const TransferInChoice& i)
  {
    e << static_cast< const ::configurations::Choice& > (i);

    // chosenConfiguration
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const TransferInChoice::ChosenConfigurationType& x (i.chosenConfiguration ());
      if (typeid (TransferInChoice::ChosenConfigurationType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "chosenConfiguration",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "chosenConfiguration",
          "",
          false, false, e, x);
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransferInChoice >
  _xsd_TransferInChoice_type_serializer_init (
    "TransferInChoice",
    "http://www.fuzzed.org/configurations");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

