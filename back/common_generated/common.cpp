// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <common.h>

namespace commonTypes
{
  // Model
  // 

  const Model::IdOptional& Model::
  id () const
  {
    return this->id_;
  }

  Model::IdOptional& Model::
  id ()
  {
    return this->id_;
  }

  void Model::
  id (const IdType& x)
  {
    this->id_.set (x);
  }

  void Model::
  id (const IdOptional& x)
  {
    this->id_ = x;
  }

  void Model::
  id (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // GraphNode
  // 

  const GraphNode::XOptional& GraphNode::
  x () const
  {
    return this->x_;
  }

  GraphNode::XOptional& GraphNode::
  x ()
  {
    return this->x_;
  }

  void GraphNode::
  x (const XType& x)
  {
    this->x_.set (x);
  }

  void GraphNode::
  x (const XOptional& x)
  {
    this->x_ = x;
  }

  const GraphNode::YOptional& GraphNode::
  y () const
  {
    return this->y_;
  }

  GraphNode::YOptional& GraphNode::
  y ()
  {
    return this->y_;
  }

  void GraphNode::
  y (const YType& x)
  {
    this->y_.set (x);
  }

  void GraphNode::
  y (const YOptional& x)
  {
    this->y_ = x;
  }

  const GraphNode::IdOptional& GraphNode::
  id () const
  {
    return this->id_;
  }

  GraphNode::IdOptional& GraphNode::
  id ()
  {
    return this->id_;
  }

  void GraphNode::
  id (const IdType& x)
  {
    this->id_.set (x);
  }

  void GraphNode::
  id (const IdOptional& x)
  {
    this->id_ = x;
  }

  void GraphNode::
  id (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }


  // IdList
  //

  IdList::
  IdList ()
  : ::xsd::cxx::tree::list< ::xml_schema::String, char > (this)
  {
  }

  IdList::
  IdList (size_type n, const ::xml_schema::String& x)
  : ::xsd::cxx::tree::list< ::xml_schema::String, char > (n, x, this)
  {
  }

  IdList::
  IdList (const IdList& o,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::String, char > (o, f, this)
  {
  }

  // DoubleToIntervalMap
  // 

  const DoubleToIntervalMap::ValueType& DoubleToIntervalMap::
  value () const
  {
    return this->value_.get ();
  }

  DoubleToIntervalMap::ValueType& DoubleToIntervalMap::
  value ()
  {
    return this->value_.get ();
  }

  void DoubleToIntervalMap::
  value (const ValueType& x)
  {
    this->value_.set (x);
  }

  void DoubleToIntervalMap::
  value (::std::auto_ptr< ValueType > x)
  {
    this->value_.set (x);
  }

  const DoubleToIntervalMap::KeyType& DoubleToIntervalMap::
  key () const
  {
    return this->key_.get ();
  }

  DoubleToIntervalMap::KeyType& DoubleToIntervalMap::
  key ()
  {
    return this->key_.get ();
  }

  void DoubleToIntervalMap::
  key (const KeyType& x)
  {
    this->key_.set (x);
  }


  // Interval
  // 

  const Interval::LowerBoundType& Interval::
  lowerBound () const
  {
    return this->lowerBound_.get ();
  }

  Interval::LowerBoundType& Interval::
  lowerBound ()
  {
    return this->lowerBound_.get ();
  }

  void Interval::
  lowerBound (const LowerBoundType& x)
  {
    this->lowerBound_.set (x);
  }

  const Interval::UpperBoundType& Interval::
  upperBound () const
  {
    return this->upperBound_.get ();
  }

  Interval::UpperBoundType& Interval::
  upperBound ()
  {
    return this->upperBound_.get ();
  }

  void Interval::
  upperBound (const UpperBoundType& x)
  {
    this->upperBound_.set (x);
  }


  // Issue
  // 

  const Issue::IssueIdOptional& Issue::
  issueId () const
  {
    return this->issueId_;
  }

  Issue::IssueIdOptional& Issue::
  issueId ()
  {
    return this->issueId_;
  }

  void Issue::
  issueId (const IssueIdType& x)
  {
    this->issueId_.set (x);
  }

  void Issue::
  issueId (const IssueIdOptional& x)
  {
    this->issueId_ = x;
  }

  const Issue::ElementIdOptional& Issue::
  elementId () const
  {
    return this->elementId_;
  }

  Issue::ElementIdOptional& Issue::
  elementId ()
  {
    return this->elementId_;
  }

  void Issue::
  elementId (const ElementIdType& x)
  {
    this->elementId_.set (x);
  }

  void Issue::
  elementId (const ElementIdOptional& x)
  {
    this->elementId_ = x;
  }

  void Issue::
  elementId (::std::auto_ptr< ElementIdType > x)
  {
    this->elementId_.set (x);
  }

  const Issue::MessageOptional& Issue::
  message () const
  {
    return this->message_;
  }

  Issue::MessageOptional& Issue::
  message ()
  {
    return this->message_;
  }

  void Issue::
  message (const MessageType& x)
  {
    this->message_.set (x);
  }

  void Issue::
  message (const MessageOptional& x)
  {
    this->message_ = x;
  }

  void Issue::
  message (::std::auto_ptr< MessageType > x)
  {
    this->message_.set (x);
  }

  const Issue::IsFatalOptional& Issue::
  isFatal () const
  {
    return this->isFatal_;
  }

  Issue::IsFatalOptional& Issue::
  isFatal ()
  {
    return this->isFatal_;
  }

  void Issue::
  isFatal (const IsFatalType& x)
  {
    this->isFatal_.set (x);
  }

  void Issue::
  isFatal (const IsFatalOptional& x)
  {
    this->isFatal_ = x;
  }


  // Probability
  // 


  // CrispProbability
  // 

  const CrispProbability::ValType& CrispProbability::
  val () const
  {
    return this->val_.get ();
  }

  CrispProbability::ValType& CrispProbability::
  val ()
  {
    return this->val_.get ();
  }

  void CrispProbability::
  val (const ValType& x)
  {
    this->val_.set (x);
  }


  // DecomposedFuzzyProbability
  // 

  const DecomposedFuzzyProbability::AlphaCutsSequence& DecomposedFuzzyProbability::
  alphaCuts () const
  {
    return this->alphaCuts_;
  }

  DecomposedFuzzyProbability::AlphaCutsSequence& DecomposedFuzzyProbability::
  alphaCuts ()
  {
    return this->alphaCuts_;
  }

  void DecomposedFuzzyProbability::
  alphaCuts (const AlphaCutsSequence& s)
  {
    this->alphaCuts_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace commonTypes
{
  // Model
  //

  Model::
  Model ()
  : ::xml_schema::Type (),
    id_ (this)
  {
  }

  Model::
  Model (const Model& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  Model::
  Model (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Model::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  Model* Model::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Model (*this, f, c);
  }

  Model& Model::
  operator= (const Model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  Model::
  ~Model ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Model >
  _xsd_Model_type_factory_init (
    "Model",
    "http://www.fuzzed.org/commonTypes");

  // GraphNode
  //

  GraphNode::
  GraphNode ()
  : ::xml_schema::Type (),
    x_ (this),
    y_ (this),
    id_ (this)
  {
  }

  GraphNode::
  GraphNode (const GraphNode& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    id_ (x.id_, f, this)
  {
  }

  GraphNode::
  GraphNode (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    x_ (this),
    y_ (this),
    id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void GraphNode::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (XTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (YTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  GraphNode* GraphNode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GraphNode (*this, f, c);
  }

  GraphNode& GraphNode::
  operator= (const GraphNode& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
      this->id_ = x.id_;
    }

    return *this;
  }

  GraphNode::
  ~GraphNode ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, GraphNode >
  _xsd_GraphNode_type_factory_init (
    "GraphNode",
    "http://www.fuzzed.org/commonTypes");

  // IdList
  //

  IdList::
  IdList (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::String, char > (e, f, this)
  {
  }

  IdList::
  IdList (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::String, char > (a, f, this)
  {
  }

  IdList::
  IdList (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::String, char > (s, e, f, this)
  {
  }

  IdList* IdList::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IdList (*this, f, c);
  }

  IdList::
  ~IdList ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, IdList >
  _xsd_IdList_type_factory_init (
    "idList",
    "http://www.fuzzed.org/commonTypes");

  // DoubleToIntervalMap
  //

  DoubleToIntervalMap::
  DoubleToIntervalMap (const ValueType& value,
                       const KeyType& key)
  : ::xml_schema::Type (),
    value_ (value, this),
    key_ (key, this)
  {
  }

  DoubleToIntervalMap::
  DoubleToIntervalMap (::std::auto_ptr< ValueType > value,
                       const KeyType& key)
  : ::xml_schema::Type (),
    value_ (value, this),
    key_ (key, this)
  {
  }

  DoubleToIntervalMap::
  DoubleToIntervalMap (const DoubleToIntervalMap& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this),
    key_ (x.key_, f, this)
  {
  }

  DoubleToIntervalMap::
  DoubleToIntervalMap (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this),
    key_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DoubleToIntervalMap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "value",
            "",
            &::xsd::cxx::tree::factory_impl< ValueType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!value_.present ())
          {
            ::std::auto_ptr< ValueType > r (
              dynamic_cast< ValueType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->value_.set (r);
            continue;
          }
        }
      }

      break;
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "key" && n.namespace_ ().empty ())
      {
        this->key_.set (KeyTraits::create (i, f, this));
        continue;
      }
    }

    if (!key_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "key",
        "");
    }
  }

  DoubleToIntervalMap* DoubleToIntervalMap::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DoubleToIntervalMap (*this, f, c);
  }

  DoubleToIntervalMap& DoubleToIntervalMap::
  operator= (const DoubleToIntervalMap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
      this->key_ = x.key_;
    }

    return *this;
  }

  DoubleToIntervalMap::
  ~DoubleToIntervalMap ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DoubleToIntervalMap >
  _xsd_DoubleToIntervalMap_type_factory_init (
    "DoubleToIntervalMap",
    "http://www.fuzzed.org/commonTypes");

  // Interval
  //

  Interval::
  Interval (const LowerBoundType& lowerBound,
            const UpperBoundType& upperBound)
  : ::xml_schema::Type (),
    lowerBound_ (lowerBound, this),
    upperBound_ (upperBound, this)
  {
  }

  Interval::
  Interval (const Interval& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    lowerBound_ (x.lowerBound_, f, this),
    upperBound_ (x.upperBound_, f, this)
  {
  }

  Interval::
  Interval (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    lowerBound_ (this),
    upperBound_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Interval::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lowerBound" && n.namespace_ ().empty ())
      {
        this->lowerBound_.set (LowerBoundTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "upperBound" && n.namespace_ ().empty ())
      {
        this->upperBound_.set (UpperBoundTraits::create (i, f, this));
        continue;
      }
    }

    if (!lowerBound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lowerBound",
        "");
    }

    if (!upperBound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "upperBound",
        "");
    }
  }

  Interval* Interval::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Interval (*this, f, c);
  }

  Interval& Interval::
  operator= (const Interval& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->lowerBound_ = x.lowerBound_;
      this->upperBound_ = x.upperBound_;
    }

    return *this;
  }

  Interval::
  ~Interval ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Interval >
  _xsd_Interval_type_factory_init (
    "Interval",
    "http://www.fuzzed.org/commonTypes");

  // Issue
  //

  Issue::
  Issue ()
  : ::xml_schema::Type (),
    issueId_ (this),
    elementId_ (this),
    message_ (this),
    isFatal_ (this)
  {
  }

  Issue::
  Issue (const Issue& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    issueId_ (x.issueId_, f, this),
    elementId_ (x.elementId_, f, this),
    message_ (x.message_, f, this),
    isFatal_ (x.isFatal_, f, this)
  {
  }

  Issue::
  Issue (const ::xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    issueId_ (this),
    elementId_ (this),
    message_ (this),
    isFatal_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Issue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "issueId" && n.namespace_ ().empty ())
      {
        this->issueId_.set (IssueIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "elementId" && n.namespace_ ().empty ())
      {
        this->elementId_.set (ElementIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "message" && n.namespace_ ().empty ())
      {
        this->message_.set (MessageTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "isFatal" && n.namespace_ ().empty ())
      {
        this->isFatal_.set (IsFatalTraits::create (i, f, this));
        continue;
      }
    }
  }

  Issue* Issue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Issue (*this, f, c);
  }

  Issue& Issue::
  operator= (const Issue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->issueId_ = x.issueId_;
      this->elementId_ = x.elementId_;
      this->message_ = x.message_;
      this->isFatal_ = x.isFatal_;
    }

    return *this;
  }

  Issue::
  ~Issue ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Issue >
  _xsd_Issue_type_factory_init (
    "Issue",
    "http://www.fuzzed.org/commonTypes");

  // Probability
  //

  Probability::
  Probability ()
  : ::xml_schema::Type ()
  {
  }

  Probability::
  Probability (const Probability& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  Probability::
  Probability (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  Probability::
  Probability (const ::xercesc::DOMAttr& a,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  Probability::
  Probability (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  Probability* Probability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Probability (*this, f, c);
  }

  Probability::
  ~Probability ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Probability >
  _xsd_Probability_type_factory_init (
    "Probability",
    "http://www.fuzzed.org/commonTypes");

  // CrispProbability
  //

  CrispProbability::
  CrispProbability (const ValType& val)
  : ::commonTypes::Probability (),
    val_ (val, this)
  {
  }

  CrispProbability::
  CrispProbability (const CrispProbability& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::commonTypes::Probability (x, f, c),
    val_ (x.val_, f, this)
  {
  }

  CrispProbability::
  CrispProbability (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::commonTypes::Probability (e, f | ::xml_schema::Flags::base, c),
    val_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CrispProbability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "val" && n.namespace_ ().empty ())
      {
        this->val_.set (ValTraits::create (i, f, this));
        continue;
      }
    }

    if (!val_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "val",
        "");
    }
  }

  CrispProbability* CrispProbability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CrispProbability (*this, f, c);
  }

  CrispProbability& CrispProbability::
  operator= (const CrispProbability& x)
  {
    if (this != &x)
    {
      static_cast< ::commonTypes::Probability& > (*this) = x;
      this->val_ = x.val_;
    }

    return *this;
  }

  CrispProbability::
  ~CrispProbability ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, CrispProbability >
  _xsd_CrispProbability_type_factory_init (
    "CrispProbability",
    "http://www.fuzzed.org/commonTypes");

  // DecomposedFuzzyProbability
  //

  DecomposedFuzzyProbability::
  DecomposedFuzzyProbability ()
  : ::commonTypes::Probability (),
    alphaCuts_ (this)
  {
  }

  DecomposedFuzzyProbability::
  DecomposedFuzzyProbability (const DecomposedFuzzyProbability& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::commonTypes::Probability (x, f, c),
    alphaCuts_ (x.alphaCuts_, f, this)
  {
  }

  DecomposedFuzzyProbability::
  DecomposedFuzzyProbability (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::commonTypes::Probability (e, f | ::xml_schema::Flags::base, c),
    alphaCuts_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DecomposedFuzzyProbability::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // alphaCuts
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "alphaCuts",
            "",
            &::xsd::cxx::tree::factory_impl< AlphaCutsType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< AlphaCutsType > r (
            dynamic_cast< AlphaCutsType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->alphaCuts_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  DecomposedFuzzyProbability* DecomposedFuzzyProbability::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DecomposedFuzzyProbability (*this, f, c);
  }

  DecomposedFuzzyProbability& DecomposedFuzzyProbability::
  operator= (const DecomposedFuzzyProbability& x)
  {
    if (this != &x)
    {
      static_cast< ::commonTypes::Probability& > (*this) = x;
      this->alphaCuts_ = x.alphaCuts_;
    }

    return *this;
  }

  DecomposedFuzzyProbability::
  ~DecomposedFuzzyProbability ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, DecomposedFuzzyProbability >
  _xsd_DecomposedFuzzyProbability_type_factory_init (
    "DecomposedFuzzyProbability",
    "http://www.fuzzed.org/commonTypes");
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace commonTypes
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace commonTypes
{
  void
  operator<< (::xercesc::DOMElement& e, const Model& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // id
    //
    if (i.id ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.id ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Model >
  _xsd_Model_type_serializer_init (
    "Model",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const GraphNode& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // x
    //
    if (i.x ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << *i.x ();
    }

    // y
    //
    if (i.y ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << *i.y ();
    }

    // id
    //
    if (i.id ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.id ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GraphNode >
  _xsd_GraphNode_type_serializer_init (
    "GraphNode",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const IdList& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::String, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const IdList& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::String, char >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const IdList& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::String, char >& > (i);
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, IdList >
  _xsd_IdList_type_serializer_init (
    "idList",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const DoubleToIntervalMap& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // value
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      const DoubleToIntervalMap::ValueType& x (i.value ());
      if (typeid (DoubleToIntervalMap::ValueType) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "value",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "value",
          "",
          false, false, e, x);
    }

    // key
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "key",
          e));

      a << ::xml_schema::AsDouble(i.key ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DoubleToIntervalMap >
  _xsd_DoubleToIntervalMap_type_serializer_init (
    "DoubleToIntervalMap",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const Interval& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // lowerBound
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "lowerBound",
          e));

      a << ::xml_schema::AsDouble(i.lowerBound ());
    }

    // upperBound
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "upperBound",
          e));

      a << ::xml_schema::AsDouble(i.upperBound ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Interval >
  _xsd_Interval_type_serializer_init (
    "Interval",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const Issue& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // issueId
    //
    if (i.issueId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "issueId",
          e));

      a << *i.issueId ();
    }

    // elementId
    //
    if (i.elementId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "elementId",
          e));

      a << *i.elementId ();
    }

    // message
    //
    if (i.message ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "message",
          e));

      a << *i.message ();
    }

    // isFatal
    //
    if (i.isFatal ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "isFatal",
          e));

      a << *i.isFatal ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Issue >
  _xsd_Issue_type_serializer_init (
    "Issue",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const Probability& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr&, const Probability&)
  {
  }

  void
  operator<< (::xml_schema::ListStream&,
              const Probability&)
  {
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Probability >
  _xsd_Probability_type_serializer_init (
    "Probability",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const CrispProbability& i)
  {
    e << static_cast< const ::commonTypes::Probability& > (i);

    // val
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "val",
          e));

      a << ::xml_schema::AsDouble(i.val ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CrispProbability >
  _xsd_CrispProbability_type_serializer_init (
    "CrispProbability",
    "http://www.fuzzed.org/commonTypes");


  void
  operator<< (::xercesc::DOMElement& e, const DecomposedFuzzyProbability& i)
  {
    e << static_cast< const ::commonTypes::Probability& > (i);

    // alphaCuts
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (DecomposedFuzzyProbability::AlphaCutsConstIterator
           b (i.alphaCuts ().begin ()), n (i.alphaCuts ().end ());
           b != n; ++b)
      {
        if (typeid (DecomposedFuzzyProbability::AlphaCutsType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "alphaCuts",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "alphaCuts",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DecomposedFuzzyProbability >
  _xsd_DecomposedFuzzyProbability_type_serializer_init (
    "DecomposedFuzzyProbability",
    "http://www.fuzzed.org/commonTypes");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

