// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include <backend.h>

namespace backendResults
{
  // Result
  // 

  const Result::IssueSequence& Result::
  issue () const
  {
    return this->issue_;
  }

  Result::IssueSequence& Result::
  issue ()
  {
    return this->issue_;
  }

  void Result::
  issue (const IssueSequence& s)
  {
    this->issue_ = s;
  }

  const Result::IdOptional& Result::
  id () const
  {
    return this->id_;
  }

  Result::IdOptional& Result::
  id ()
  {
    return this->id_;
  }

  void Result::
  id (const IdType& x)
  {
    this->id_.set (x);
  }

  void Result::
  id (const IdOptional& x)
  {
    this->id_ = x;
  }

  void Result::
  id (::std::auto_ptr< IdType > x)
  {
    this->id_.set (x);
  }

  const Result::ModelIdType& Result::
  modelId () const
  {
    return this->modelId_.get ();
  }

  Result::ModelIdType& Result::
  modelId ()
  {
    return this->modelId_.get ();
  }

  void Result::
  modelId (const ModelIdType& x)
  {
    this->modelId_.set (x);
  }

  void Result::
  modelId (::std::auto_ptr< ModelIdType > x)
  {
    this->modelId_.set (x);
  }

  const Result::ConfigIdType& Result::
  configId () const
  {
    return this->configId_.get ();
  }

  Result::ConfigIdType& Result::
  configId ()
  {
    return this->configId_.get ();
  }

  void Result::
  configId (const ConfigIdType& x)
  {
    this->configId_.set (x);
  }

  void Result::
  configId (::std::auto_ptr< ConfigIdType > x)
  {
    this->configId_.set (x);
  }

  const Result::TimestampType& Result::
  timestamp () const
  {
    return this->timestamp_.get ();
  }

  Result::TimestampType& Result::
  timestamp ()
  {
    return this->timestamp_.get ();
  }

  void Result::
  timestamp (const TimestampType& x)
  {
    this->timestamp_.set (x);
  }

  void Result::
  timestamp (::std::auto_ptr< TimestampType > x)
  {
    this->timestamp_.set (x);
  }

  const Result::ValidResultType& Result::
  validResult () const
  {
    return this->validResult_.get ();
  }

  Result::ValidResultType& Result::
  validResult ()
  {
    return this->validResult_.get ();
  }

  void Result::
  validResult (const ValidResultType& x)
  {
    this->validResult_.set (x);
  }


  // MincutResult
  // 

  const MincutResult::NodeidSequence& MincutResult::
  nodeid () const
  {
    return this->nodeid_;
  }

  MincutResult::NodeidSequence& MincutResult::
  nodeid ()
  {
    return this->nodeid_;
  }

  void MincutResult::
  nodeid (const NodeidSequence& s)
  {
    this->nodeid_ = s;
  }


  // SimulationResult
  // 

  const SimulationResult::ReliabilityType& SimulationResult::
  reliability () const
  {
    return this->reliability_.get ();
  }

  SimulationResult::ReliabilityType& SimulationResult::
  reliability ()
  {
    return this->reliability_.get ();
  }

  void SimulationResult::
  reliability (const ReliabilityType& x)
  {
    this->reliability_.set (x);
  }

  const SimulationResult::NFailuresType& SimulationResult::
  nFailures () const
  {
    return this->nFailures_.get ();
  }

  SimulationResult::NFailuresType& SimulationResult::
  nFailures ()
  {
    return this->nFailures_.get ();
  }

  void SimulationResult::
  nFailures (const NFailuresType& x)
  {
    this->nFailures_.set (x);
  }

  const SimulationResult::NSimulatedRoundsType& SimulationResult::
  nSimulatedRounds () const
  {
    return this->nSimulatedRounds_.get ();
  }

  SimulationResult::NSimulatedRoundsType& SimulationResult::
  nSimulatedRounds ()
  {
    return this->nSimulatedRounds_.get ();
  }

  void SimulationResult::
  nSimulatedRounds (const NSimulatedRoundsType& x)
  {
    this->nSimulatedRounds_.set (x);
  }

  const SimulationResult::AvailabilityOptional& SimulationResult::
  availability () const
  {
    return this->availability_;
  }

  SimulationResult::AvailabilityOptional& SimulationResult::
  availability ()
  {
    return this->availability_;
  }

  void SimulationResult::
  availability (const AvailabilityType& x)
  {
    this->availability_.set (x);
  }

  void SimulationResult::
  availability (const AvailabilityOptional& x)
  {
    this->availability_ = x;
  }

  const SimulationResult::DurationOptional& SimulationResult::
  duration () const
  {
    return this->duration_;
  }

  SimulationResult::DurationOptional& SimulationResult::
  duration ()
  {
    return this->duration_;
  }

  void SimulationResult::
  duration (const DurationType& x)
  {
    this->duration_.set (x);
  }

  void SimulationResult::
  duration (const DurationOptional& x)
  {
    this->duration_ = x;
  }

  const SimulationResult::MttfOptional& SimulationResult::
  mttf () const
  {
    return this->mttf_;
  }

  SimulationResult::MttfOptional& SimulationResult::
  mttf ()
  {
    return this->mttf_;
  }

  void SimulationResult::
  mttf (const MttfType& x)
  {
    this->mttf_.set (x);
  }

  void SimulationResult::
  mttf (const MttfOptional& x)
  {
    this->mttf_ = x;
  }


  // AnalysisResult
  // 

  const AnalysisResult::ProbabilityOptional& AnalysisResult::
  probability () const
  {
    return this->probability_;
  }

  AnalysisResult::ProbabilityOptional& AnalysisResult::
  probability ()
  {
    return this->probability_;
  }

  void AnalysisResult::
  probability (const ProbabilityType& x)
  {
    this->probability_.set (x);
  }

  void AnalysisResult::
  probability (const ProbabilityOptional& x)
  {
    this->probability_ = x;
  }

  void AnalysisResult::
  probability (::std::auto_ptr< ProbabilityType > x)
  {
    this->probability_.set (x);
  }

  const AnalysisResult::DecompositionNumberType& AnalysisResult::
  decompositionNumber () const
  {
    return this->decompositionNumber_.get ();
  }

  AnalysisResult::DecompositionNumberType& AnalysisResult::
  decompositionNumber ()
  {
    return this->decompositionNumber_.get ();
  }

  void AnalysisResult::
  decompositionNumber (const DecompositionNumberType& x)
  {
    this->decompositionNumber_.set (x);
  }


  // BackendResults
  // 

  const BackendResults::ConfigurationSequence& BackendResults::
  configuration () const
  {
    return this->configuration_;
  }

  BackendResults::ConfigurationSequence& BackendResults::
  configuration ()
  {
    return this->configuration_;
  }

  void BackendResults::
  configuration (const ConfigurationSequence& s)
  {
    this->configuration_ = s;
  }

  const BackendResults::ResultSequence& BackendResults::
  result () const
  {
    return this->result_;
  }

  BackendResults::ResultSequence& BackendResults::
  result ()
  {
    return this->result_;
  }

  void BackendResults::
  result (const ResultSequence& s)
  {
    this->result_ = s;
  }

  const BackendResults::IssueSequence& BackendResults::
  issue () const
  {
    return this->issue_;
  }

  BackendResults::IssueSequence& BackendResults::
  issue ()
  {
    return this->issue_;
  }

  void BackendResults::
  issue (const IssueSequence& s)
  {
    this->issue_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace backendResults
{
  // Result
  //

  Result::
  Result (const ModelIdType& modelId,
          const ConfigIdType& configId,
          const TimestampType& timestamp,
          const ValidResultType& validResult)
  : ::xml_schema::Type (),
    issue_ (this),
    id_ (this),
    modelId_ (modelId, this),
    configId_ (configId, this),
    timestamp_ (timestamp, this),
    validResult_ (validResult, this)
  {
  }

  Result::
  Result (const Result& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    issue_ (x.issue_, f, this),
    id_ (x.id_, f, this),
    modelId_ (x.modelId_, f, this),
    configId_ (x.configId_, f, this),
    timestamp_ (x.timestamp_, f, this),
    validResult_ (x.validResult_, f, this)
  {
  }

  Result::
  Result (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    issue_ (this),
    id_ (this),
    modelId_ (this),
    configId_ (this),
    timestamp_ (this),
    validResult_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Result::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // issue
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "issue",
            "",
            &::xsd::cxx::tree::factory_impl< IssueType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< IssueType > r (
            dynamic_cast< IssueType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->issue_.push_back (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "modelId" && n.namespace_ ().empty ())
      {
        this->modelId_.set (ModelIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "configId" && n.namespace_ ().empty ())
      {
        this->configId_.set (ConfigIdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "timestamp" && n.namespace_ ().empty ())
      {
        this->timestamp_.set (TimestampTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "validResult" && n.namespace_ ().empty ())
      {
        this->validResult_.set (ValidResultTraits::create (i, f, this));
        continue;
      }
    }

    if (!modelId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "modelId",
        "");
    }

    if (!configId_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "configId",
        "");
    }

    if (!timestamp_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "timestamp",
        "");
    }

    if (!validResult_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "validResult",
        "");
    }
  }

  Result* Result::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Result (*this, f, c);
  }

  Result& Result::
  operator= (const Result& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->issue_ = x.issue_;
      this->id_ = x.id_;
      this->modelId_ = x.modelId_;
      this->configId_ = x.configId_;
      this->timestamp_ = x.timestamp_;
      this->validResult_ = x.validResult_;
    }

    return *this;
  }

  Result::
  ~Result ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, Result >
  _xsd_Result_type_factory_init (
    "Result",
    "http://www.fuzzed.org/backendResults");

  // MincutResult
  //

  MincutResult::
  MincutResult (const ModelIdType& modelId,
                const ConfigIdType& configId,
                const TimestampType& timestamp,
                const ValidResultType& validResult)
  : ::backendResults::Result (modelId,
                              configId,
                              timestamp,
                              validResult),
    nodeid_ (this)
  {
  }

  MincutResult::
  MincutResult (const MincutResult& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::backendResults::Result (x, f, c),
    nodeid_ (x.nodeid_, f, this)
  {
  }

  MincutResult::
  MincutResult (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::backendResults::Result (e, f | ::xml_schema::Flags::base, c),
    nodeid_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MincutResult::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::backendResults::Result::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nodeid
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "nodeid",
            "",
            &::xsd::cxx::tree::factory_impl< NodeidType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< NodeidType > r (
            dynamic_cast< NodeidType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->nodeid_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  MincutResult* MincutResult::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MincutResult (*this, f, c);
  }

  MincutResult& MincutResult::
  operator= (const MincutResult& x)
  {
    if (this != &x)
    {
      static_cast< ::backendResults::Result& > (*this) = x;
      this->nodeid_ = x.nodeid_;
    }

    return *this;
  }

  MincutResult::
  ~MincutResult ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MincutResult >
  _xsd_MincutResult_type_factory_init (
    "MincutResult",
    "http://www.fuzzed.org/backendResults");

  // SimulationResult
  //

  SimulationResult::
  SimulationResult (const ModelIdType& modelId,
                    const ConfigIdType& configId,
                    const TimestampType& timestamp,
                    const ValidResultType& validResult,
                    const ReliabilityType& reliability,
                    const NFailuresType& nFailures,
                    const NSimulatedRoundsType& nSimulatedRounds)
  : ::backendResults::Result (modelId,
                              configId,
                              timestamp,
                              validResult),
    reliability_ (reliability, this),
    nFailures_ (nFailures, this),
    nSimulatedRounds_ (nSimulatedRounds, this),
    availability_ (this),
    duration_ (this),
    mttf_ (this)
  {
  }

  SimulationResult::
  SimulationResult (const SimulationResult& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::backendResults::Result (x, f, c),
    reliability_ (x.reliability_, f, this),
    nFailures_ (x.nFailures_, f, this),
    nSimulatedRounds_ (x.nSimulatedRounds_, f, this),
    availability_ (x.availability_, f, this),
    duration_ (x.duration_, f, this),
    mttf_ (x.mttf_, f, this)
  {
  }

  SimulationResult::
  SimulationResult (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::backendResults::Result (e, f | ::xml_schema::Flags::base, c),
    reliability_ (this),
    nFailures_ (this),
    nSimulatedRounds_ (this),
    availability_ (this),
    duration_ (this),
    mttf_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SimulationResult::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::backendResults::Result::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "reliability" && n.namespace_ ().empty ())
      {
        this->reliability_.set (ReliabilityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "nFailures" && n.namespace_ ().empty ())
      {
        this->nFailures_.set (NFailuresTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "nSimulatedRounds" && n.namespace_ ().empty ())
      {
        this->nSimulatedRounds_.set (NSimulatedRoundsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "availability" && n.namespace_ ().empty ())
      {
        this->availability_.set (AvailabilityTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (DurationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "mttf" && n.namespace_ ().empty ())
      {
        this->mttf_.set (MttfTraits::create (i, f, this));
        continue;
      }
    }

    if (!reliability_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "reliability",
        "");
    }

    if (!nFailures_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "nFailures",
        "");
    }

    if (!nSimulatedRounds_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "nSimulatedRounds",
        "");
    }
  }

  SimulationResult* SimulationResult::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SimulationResult (*this, f, c);
  }

  SimulationResult& SimulationResult::
  operator= (const SimulationResult& x)
  {
    if (this != &x)
    {
      static_cast< ::backendResults::Result& > (*this) = x;
      this->reliability_ = x.reliability_;
      this->nFailures_ = x.nFailures_;
      this->nSimulatedRounds_ = x.nSimulatedRounds_;
      this->availability_ = x.availability_;
      this->duration_ = x.duration_;
      this->mttf_ = x.mttf_;
    }

    return *this;
  }

  SimulationResult::
  ~SimulationResult ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, SimulationResult >
  _xsd_SimulationResult_type_factory_init (
    "SimulationResult",
    "http://www.fuzzed.org/backendResults");

  // AnalysisResult
  //

  AnalysisResult::
  AnalysisResult (const ModelIdType& modelId,
                  const ConfigIdType& configId,
                  const TimestampType& timestamp,
                  const ValidResultType& validResult,
                  const DecompositionNumberType& decompositionNumber)
  : ::backendResults::Result (modelId,
                              configId,
                              timestamp,
                              validResult),
    probability_ (this),
    decompositionNumber_ (decompositionNumber, this)
  {
  }

  AnalysisResult::
  AnalysisResult (const AnalysisResult& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::backendResults::Result (x, f, c),
    probability_ (x.probability_, f, this),
    decompositionNumber_ (x.decompositionNumber_, f, this)
  {
  }

  AnalysisResult::
  AnalysisResult (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::backendResults::Result (e, f | ::xml_schema::Flags::base, c),
    probability_ (this),
    decompositionNumber_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AnalysisResult::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::backendResults::Result::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // probability
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "probability",
            "",
            &::xsd::cxx::tree::factory_impl< ProbabilityType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->probability_)
          {
            ::std::auto_ptr< ProbabilityType > r (
              dynamic_cast< ProbabilityType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->probability_.set (r);
            continue;
          }
        }
      }

      break;
    }

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "decompositionNumber" && n.namespace_ ().empty ())
      {
        this->decompositionNumber_.set (DecompositionNumberTraits::create (i, f, this));
        continue;
      }
    }

    if (!decompositionNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "decompositionNumber",
        "");
    }
  }

  AnalysisResult* AnalysisResult::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AnalysisResult (*this, f, c);
  }

  AnalysisResult& AnalysisResult::
  operator= (const AnalysisResult& x)
  {
    if (this != &x)
    {
      static_cast< ::backendResults::Result& > (*this) = x;
      this->probability_ = x.probability_;
      this->decompositionNumber_ = x.decompositionNumber_;
    }

    return *this;
  }

  AnalysisResult::
  ~AnalysisResult ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, AnalysisResult >
  _xsd_AnalysisResult_type_factory_init (
    "AnalysisResult",
    "http://www.fuzzed.org/backendResults");

  // BackendResults
  //

  BackendResults::
  BackendResults ()
  : ::xml_schema::Type (),
    configuration_ (this),
    result_ (this),
    issue_ (this)
  {
  }

  BackendResults::
  BackendResults (const BackendResults& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    configuration_ (x.configuration_, f, this),
    result_ (x.result_, f, this),
    issue_ (x.issue_, f, this)
  {
  }

  BackendResults::
  BackendResults (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    configuration_ (this),
    result_ (this),
    issue_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void BackendResults::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // configuration
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "configuration",
            "",
            &::xsd::cxx::tree::factory_impl< ConfigurationType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< ConfigurationType > r (
            dynamic_cast< ConfigurationType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->configuration_.push_back (r);
          continue;
        }
      }

      // result
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "result",
            "",
            &::xsd::cxx::tree::factory_impl< ResultType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< ResultType > r (
            dynamic_cast< ResultType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->result_.push_back (r);
          continue;
        }
      }

      // issue
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "issue",
            "",
            &::xsd::cxx::tree::factory_impl< IssueType >,
            false, false, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::auto_ptr< IssueType > r (
            dynamic_cast< IssueType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->issue_.push_back (r);
          continue;
        }
      }

      break;
    }
  }

  BackendResults* BackendResults::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BackendResults (*this, f, c);
  }

  BackendResults& BackendResults::
  operator= (const BackendResults& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->configuration_ = x.configuration_;
      this->result_ = x.result_;
      this->issue_ = x.issue_;
    }

    return *this;
  }

  BackendResults::
  ~BackendResults ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace backendResults
{
  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (const ::std::string& u,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::backendResults::BackendResults > (
      ::backendResults::backendResults (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (const ::std::string& u,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::backendResults::BackendResults > (
      ::backendResults::backendResults (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::backendResults::BackendResults > (
      ::backendResults::backendResults (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::std::istream& is,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::backendResults::backendResults (isrc, f, p);
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::std::istream& is,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::backendResults::backendResults (isrc, h, f, p);
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::backendResults::backendResults (isrc, h, f, p);
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::backendResults::backendResults (isrc, f, p);
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::backendResults::backendResults (isrc, h, f, p);
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::backendResults::backendResults (isrc, h, f, p);
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::xercesc::InputSource& i,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::backendResults::BackendResults > (
      ::backendResults::backendResults (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::xercesc::InputSource& i,
                  ::xml_schema::ErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::backendResults::BackendResults > (
      ::backendResults::backendResults (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::backendResults::BackendResults > (
      ::backendResults::backendResults (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (const ::xercesc::DOMDocument& doc,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::backendResults::BackendResults > (
        ::backendResults::backendResults (
          d, f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "backendResults" &&
        n.namespace_ () == "http://www.fuzzed.org/backendResults")
    {
      ::std::auto_ptr< ::backendResults::BackendResults > r (
        ::xsd::cxx::tree::traits< ::backendResults::BackendResults, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "backendResults",
      "http://www.fuzzed.org/backendResults");
  }

  ::std::auto_ptr< ::backendResults::BackendResults >
  backendResults (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                  ::xml_schema::Flags f,
                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "backendResults" &&
        n.namespace_ () == "http://www.fuzzed.org/backendResults")
    {
      ::std::auto_ptr< ::backendResults::BackendResults > r (
        ::xsd::cxx::tree::traits< ::backendResults::BackendResults, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "backendResults",
      "http://www.fuzzed.org/backendResults");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace backendResults
{
  void
  operator<< (::xercesc::DOMElement& e, const Result& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // issue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (Result::IssueConstIterator
           b (i.issue ().begin ()), n (i.issue ().end ());
           b != n; ++b)
      {
        if (typeid (Result::IssueType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "issue",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "issue",
            "",
            false, false, e, *b);
      }
    }

    // id
    //
    if (i.id ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << *i.id ();
    }

    // modelId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "modelId",
          e));

      a << i.modelId ();
    }

    // configId
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "configId",
          e));

      a << i.configId ();
    }

    // timestamp
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "timestamp",
          e));

      a << i.timestamp ();
    }

    // validResult
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "validResult",
          e));

      a << i.validResult ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, Result >
  _xsd_Result_type_serializer_init (
    "Result",
    "http://www.fuzzed.org/backendResults");


  void
  operator<< (::xercesc::DOMElement& e, const MincutResult& i)
  {
    e << static_cast< const ::backendResults::Result& > (i);

    // nodeid
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (MincutResult::NodeidConstIterator
           b (i.nodeid ().begin ()), n (i.nodeid ().end ());
           b != n; ++b)
      {
        if (typeid (MincutResult::NodeidType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "nodeid",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "nodeid",
            "",
            false, false, e, *b);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MincutResult >
  _xsd_MincutResult_type_serializer_init (
    "MincutResult",
    "http://www.fuzzed.org/backendResults");


  void
  operator<< (::xercesc::DOMElement& e, const SimulationResult& i)
  {
    e << static_cast< const ::backendResults::Result& > (i);

    // reliability
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "reliability",
          e));

      a << ::xml_schema::AsDouble(i.reliability ());
    }

    // nFailures
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nFailures",
          e));

      a << i.nFailures ();
    }

    // nSimulatedRounds
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "nSimulatedRounds",
          e));

      a << i.nSimulatedRounds ();
    }

    // availability
    //
    if (i.availability ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "availability",
          e));

      a << ::xml_schema::AsDouble(*i.availability ());
    }

    // duration
    //
    if (i.duration ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "duration",
          e));

      a << ::xml_schema::AsDouble(*i.duration ());
    }

    // mttf
    //
    if (i.mttf ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mttf",
          e));

      a << ::xml_schema::AsDouble(*i.mttf ());
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SimulationResult >
  _xsd_SimulationResult_type_serializer_init (
    "SimulationResult",
    "http://www.fuzzed.org/backendResults");


  void
  operator<< (::xercesc::DOMElement& e, const AnalysisResult& i)
  {
    e << static_cast< const ::backendResults::Result& > (i);

    // probability
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.probability ())
      {
        const AnalysisResult::ProbabilityType& x (*i.probability ());
        if (typeid (AnalysisResult::ProbabilityType) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "probability",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "probability",
            "",
            false, false, e, x);
      }
    }

    // decompositionNumber
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "decompositionNumber",
          e));

      a << i.decompositionNumber ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AnalysisResult >
  _xsd_AnalysisResult_type_serializer_init (
    "AnalysisResult",
    "http://www.fuzzed.org/backendResults");


  void
  backendResults (::std::ostream& o,
                  const ::backendResults::BackendResults& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::backendResults::backendResults (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  backendResults (::std::ostream& o,
                  const ::backendResults::BackendResults& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::backendResults::backendResults (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  backendResults (::std::ostream& o,
                  const ::backendResults::BackendResults& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::backendResults::backendResults (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  backendResults (::xercesc::XMLFormatTarget& t,
                  const ::backendResults::BackendResults& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::backendResults::backendResults (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  backendResults (::xercesc::XMLFormatTarget& t,
                  const ::backendResults::BackendResults& s,
                  ::xml_schema::ErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::backendResults::backendResults (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  backendResults (::xercesc::XMLFormatTarget& t,
                  const ::backendResults::BackendResults& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::NamespaceInfomap& m,
                  const ::std::string& e,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::backendResults::backendResults (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  backendResults (::xercesc::DOMDocument& d,
                  const ::backendResults::BackendResults& s,
                  ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "backendResults" &&
        n.namespace_ () == "http://www.fuzzed.org/backendResults")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "backendResults",
        "http://www.fuzzed.org/backendResults");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  backendResults (const ::backendResults::BackendResults& s,
                  const ::xml_schema::NamespaceInfomap& m,
                  ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "backendResults",
        "http://www.fuzzed.org/backendResults",
        m, f));

    ::backendResults::backendResults (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const BackendResults& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // configuration
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (BackendResults::ConfigurationConstIterator
           b (i.configuration ().begin ()), n (i.configuration ().end ());
           b != n; ++b)
      {
        if (typeid (BackendResults::ConfigurationType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "configuration",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "configuration",
            "",
            false, false, e, *b);
      }
    }

    // result
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (BackendResults::ResultConstIterator
           b (i.result ().begin ()), n (i.result ().end ());
           b != n; ++b)
      {
        if (typeid (BackendResults::ResultType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "result",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "result",
            "",
            false, false, e, *b);
      }
    }

    // issue
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (BackendResults::IssueConstIterator
           b (i.issue ().begin ()), n (i.issue ().end ());
           b != n; ++b)
      {
        if (typeid (BackendResults::IssueType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "issue",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "issue",
            "",
            false, false, e, *b);
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

