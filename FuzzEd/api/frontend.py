import json
import logging

from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_GET, require_POST, require_http_methods
from django.core.urlresolvers import reverse
from django.views.decorators.cache import never_cache
from django.db.models import Q
from django.shortcuts import get_object_or_404
from tastypie.authentication import SessionAuthentication

from FuzzEd.decorators import require_ajax
from FuzzEd.models import Node, Job, NodeGroup, Graph
from FuzzEd.middleware import *
import common


logger = logging.getLogger('FuzzEd')

class JobResource(common.JobResource):
    class Meta(common.JobResource.Meta):
        authentication = SessionAuthentication()

class NotificationResource(common.NotificationResource):
    class Meta(common.NotificationResource.Meta):
        authentication = SessionAuthentication()

class NodeResource(common.NodeResource):
    class Meta(common.NodeResource.Meta):
        authentication = SessionAuthentication()

class EdgeResource(common.EdgeResource):
    class Meta(common.EdgeResource.Meta):
        authentication = SessionAuthentication()

class ProjectResource(common.ProjectResource):
    class Meta(common.ProjectResource.Meta):
        authentication = SessionAuthentication()

class GraphSerializer(common.GraphSerializer):
    """
        The frontend gets its own JSON format for the graph information,
        not the default HATEOAS format generated by Tastypie. For this reason,
        we need a frontend API specific JSON serializer.
    """
    def to_json(self, data, options=None):
        return data.obj.to_json()

class GraphResource(common.GraphResource):
    """
        Override our GraphResource Meta class to register the custom
        frontend JSON serializer and the frontent auth method.
    """
    class Meta(common.GraphResource.Meta):
        authentication = SessionAuthentication()
        serializer = GraphSerializer()

@login_required
@csrf_exempt
@require_GET
def job_status(request, job_id):
    ''' Returns the status information for the given job.
        202 is delivered if the job is pending, otherwise the result is immediately returned.
        The result may be the actual text data, or a download link to a binary file.
    '''
    status, job = common.job_status(request.user, job_id)

    if status == 0:     # done, valid result
        if job.requires_download():
            # Return the URL to the file created by the job
            return HttpResponse(job.get_absolute_url())
        else:
            # Serve directly
            return HttpResponse(job.result_rendering())
    elif status == 1:   # done and error
        raise HttpResponseServerErrorAnswer("We have an internal problem analyzing this graph. Sorry! The developers are informed.")
    elif status == 2:   # Pending             
        return HttpResponseAccepted()
    elif status == 3:   # Does not exists
        raise HttpResponseNotFoundAnswer()

@login_required
@csrf_exempt
@require_GET
def job_create(request, graph_id, job_kind):
    '''
        Starts a job of the given kind for the given graph.
        It is intended to return immediately with job information for the frontend.
    '''
    job = common.job_create(request.user, graph_id, job_kind)
    response = HttpResponse(status=201)
    response['Location'] = reverse('frontend_job_status', args=[job.pk])
    return response

@login_required
@csrf_exempt
@require_ajax
@require_GET
def graph_transfers(request, graph_id):
    """
    Function: graph_transfers

    Returns a list of transfers for the given graph

    Request Parameters: graph_id = <INT>
    Response:           200 - <TRANSFERS_AS_JSON>

    Parameters:
     {HTTPRequest} request  - the django request object
     {int}         graph_id - the id of the graph to get the transfers for

    Returns:
     {HTTPResponse} a django response object
    """
    transfers = []
    if request.user.is_staff:
        graph     = get_object_or_404(Graph, pk=graph_id)
    else:
        graph     = get_object_or_404(Graph, pk=graph_id, owner=request.user, deleted=False)        

    if graph.kind in ['faulttree', 'fuzztree']:
        for transfer in Graph.objects.filter(~Q(pk=graph_id), owner=request.user, kind=graph.kind, deleted=False):
            transfers.append({'id': transfer.pk, 'name': transfer.name})

    return HttpResponse(json.dumps({'transfers': transfers}), 'application/javascript', status=200)

@login_required
@csrf_exempt
@require_ajax
@require_POST
@never_cache
def nodegroups(request, graph_id):        

    if request.user.is_staff:
        graph = get_object_or_404(Graph, pk=graph_id)
    else:
        graph = get_object_or_404(Graph, pk=graph_id, owner=request.user, deleted=False)
    if graph.read_only:
        raise HttpResponseForbiddenAnswer('Trying to create a node in a read-only graph')

    nodeids = json.loads(request.POST['nodeIds'])
    client_id = request.POST['id']
    group = NodeGroup(client_id = client_id, graph=graph)
    group.save()        # Prepare ManyToMany relationship
    for nodeid in nodeids:
        try:
            # The client may refer to nodes that are already gone,
            # we simply ignore them
            node = Node.objects.get(pk = nodeid, deleted = False)
            group.nodes.add(node)
        except:
            pass
    group.save()    

    response = HttpResponse(group.to_json(), 'application/javascript', status=201)
    response['Location'] = reverse('nodegroup', args=[graph_id, group.client_id])
    return response

@login_required
@csrf_exempt
@require_ajax
@never_cache
def nodegroup(request, graph_id, group_id):
    try:
        group = get_object_or_404(NodeGroup, client_id=group_id, graph__pk=graph_id)

        if group.graph.read_only:
            raise HttpResponseForbiddenAnswer('Trying to modify a node in a read-only graph')

        if request.method == 'DELETE':
            group.deleted = True
            group.save()
            return HttpResponse(status=204)

    except Exception as exception:
        logger.error('Exception: ' + str(exception))
        raise exception





@csrf_exempt
@require_http_methods(['GET', 'POST'])
def job_files(request, job_secret):
    ''' Allows to retrieve a job input file (GET), or to upload job result files (POST).
        This method is expected to only be used by our backend daemon script, 
        which gets the shared secret as part of the PostgreSQL notification message.
        This reduces the security down to the ability of connecting to the PostgreSQL database,
        otherwise the job URL cannot be determined.
    '''
    job = get_object_or_404(Job, secret=job_secret)
    if request.method == 'GET':
        logger.debug("Delivering data for job %d"%job.pk)
        response = HttpResponse()
        response.content, response['Content-Type'] = job.input_data()
        logger.debug(response.content)
        return response
    elif request.method == 'POST':
        if job.done():
            logger.error("Job already done, discarding uploaded results")
            return HttpResponse() 
        else:
            logger.debug("Storing result data for job %d"%job.pk)
            # Retrieve binary file and store it
            assert(len(request.FILES.values())==1)
            job.result = request.FILES.values()[0].read()
            job.exit_code = 0       # This saves as a roundtrip. Having files means everything is ok.
            job.save()
            if not job.requires_download():
                logger.debug(''.join(job.result))
            return HttpResponse()        

@csrf_exempt
@require_http_methods(['POST'])
def job_exitcode(request, job_secret):
    ''' Allows to set the exit code of a job. 
        This method is expected to only be used by our backend daemon script, 
        which gets the shared secret as part of the PostgreSQL notification message.
        This reduces the security down to the ability of connecting to the PostgreSQL database,
        otherwise the job URL cannot be determined.
    '''
    job = get_object_or_404(Job, secret=job_secret)
    logger.debug("Storing exit code for job %d"%job.pk)
    job.exit_code = request.POST['exit_code']
    job.save()
    return HttpResponse()        


